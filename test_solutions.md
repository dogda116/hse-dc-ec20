# Решение контрольной
## A. Количество элементов, равных максимуму
Последовательность состоит из натуральных чисел и завершается числом 0. Определите, какое количество элементов этой последовательности, равны ее наибольшему элементу.  

### Решение
```python
numbers = []
num = int(input())
while num != 0:
    numbers.append(num)
    num = int(input())
print(numbers.count(max(numbers)))
```
В контесте такое решение заходит, но если бы в тестах был случай пустой последовательности (сразу вводится 0), то получили бы ошибку при применении функции `max` к пустому списку. 
Добавим проверку перед выводом ответа:
```python
if len(numbers) > 0:
    print(numbers.count(max(numbers)))
```

## B. Второе вхождение
Дана строка. Найдите в этой строке **второе** вхождение буквы f, и выведите индекс этого вхождения. 
Если буква f в данной строке встречается только один раз, выведите число -1, а если не встречается ни разу, выведите число -2.
#### Примечания
При решении этой задачи нельзя использовать метод count.

### Решение
```python
s = input()
first_index = s.find('f')
if first_index == -1:
    print(-2)
else:
    print(s.find('f', first_index+1))  # Ищем второй символ 'f' в подстроке s[first_index+1:]
```
Можно написать короче, воспользовавшись эквивалентным тернарным оператором:
```python
s = input()
print(-2) if s.find('f') == -1 else print(s.find('f', s.find('f')+1))
```
Но такой код сложнее читать, лучше так не писать)

## C. Замечательные числа - 5
Даны два четырёхзначных числа A и B. Выведите в порядке возрастания все четырёхзначные числа в интервале от A до B, запись которых содержит ровно три одинаковые цифры.

### Решение
```python
for number in range(int(input()), int(input()) + 1):
    for digit in str(number):
        if str(number).count(digit) == 3:
            print(number)
            break
```
И снова сжатая версия:
```python
for number in range(int(input()), int(input()) + 1):
    print(number) if sum([str(number).count(str(digit)) == 3 for digit in range(10)]) > 0 else None
```
Но так работает медленее из-за ненужных повторяющихся действий

## D. Таблица умножения - 2
Когда-то давно на обороте школьных тетрадок печатали таблицу умножения. 
Для каждого i от 1 до 10 был выписан свой набор произведений: для каждого j от 1 до 10 было явно записано, чему равно произведение i на j (смотрите пример). 
Вам нужно напечатать таблицу умножения в таком же формате.

#### Формат ввода
Даны целые числа m1, m2 и n1, n2, по модулю не превосходящие 100, причём m1 < m2 и n1 < n2.

#### Формат вывода
Для всех целых m из отрезка [m1, m2] напечатайте блок из произведений текущего числа m на все целые числа из [n1, n2], как показано в примере. 
Соседние блоки разделяйте пустой строкой.
### Решение
```python
m1, m2 = list(map(int, input().split()))
n1, n2 = list(map(int, input().split()))
for m in range(m1, m2 + 1):
    for n in range(n1, n2 + 1):
        print(m, 'x', n, '=', m * n)
    print()
```
В самом конце вывода будет лишняя пустая строка, но в контесте это допускалось

## E. Угадай число
Август и Беатриса играют в игру. Август загадал натуральное число от 1 до n. Беатриса пытается угадать это число, для этого она называет некоторые множества натуральных чисел. 
Август отвечает Беатрисе YES, если среди названных ей чисел есть задуманное или NO в противном случае. 
После нескольких заданных вопросов Беатриса запуталась в том, какие вопросы она задавала и какие ответы получила и просит вас помочь ей определить, 
какие числа мог задумать Август.

#### Формат ввода
Первая строка входных данных содержит число n — наибольшее число, которое мог загадать Август. Далее идут строки, содержащие вопросы Беатрисы. Каждая строка представляет собой набор чисел, разделенных пробелами. После каждой строки с вопросом идет ответ Августа: YES или NO.

Наконец, последняя строка входных данных содержит одно слово HELP.

#### Формат вывода
Вы должны вывести (через пробел, в порядке возрастания) все числа, которые мог задумать Август.

### Решение
```python
possible_numbers = set(range(1, int(input())+1))  # В самом начале возможно любое число от 1 до n включительно
beatrice_says = input()
while beatrice_says != 'HELP':
    august_says = input()
    if august_says == 'YES':
        possible_numbers &= set(map(int, beatrice_says.split()))
    else:
        possible_numbers -= set(map(int, beatrice_says.split()))
    beatrice_says = input()
print(*sorted(possible_numbers))
```
Если Август говорит YES, то в текущем множестве возможных чисел оставляем только те, что есть среди названных Беатрисой.
Иначе, если говорит NO, то из текущего множества возможных чисел убираем те, что назвала Беатриса


